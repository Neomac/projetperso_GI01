{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red63\green110\blue116;\red170\green13\blue145;
\red38\green71\blue75;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 Comparaison entre r\'e9cursif et it\'e9ratif\
\
Iteratif :\
\
Algo :\
InitialiserIndivIte ( int taille, int prob) -> ListeBit A\
Pour i de 1 a taille faire\
	Ajouter_Queue_Indiv (A, random(prob))  // on ajouter un 0 ou un 1 suivant la prob donn\'e9e\
\
Code :\
\
\pard\tx529\pardeftab529\pardirnatural

\f1\fs22 \cf2 \CocoaLigature0 /* Cree et remplie une liste de bits 'A' de 'taille' valeurs (0 ou 1) selon la probabilite choisie (entre 0 et 100) */\cf0 \
\cf2 /* Algorithme iteratif */\cf0 \
\cf3 ListeBit\cf0  InitialiserIndivIteratif (\cf4 int\cf0  taille, \cf4 int\cf0  prob)\
\{\
	\cf3 ListeBit\cf0  A;\
	\cf4 int\cf0  i;\
	\cf4 for\cf0  (i=\cf4 0\cf0 ; i<=taille; ++i)\{					\cf2 /* On ajoute en queue de la liste A des bits 0 ou 1 jusqu'a avoir la taille souhaitee */\cf0 \
		\cf5 Ajouter_Queue_Indiv\cf0 (A, \cf5 random1\cf0 (prob));\
	\}\
	\cf4 return\cf0  A;\
\}\
\
\
Avantage : \
- Code plut\'f4t clair\
\
Inconv\'e9nient :\
- Code plut\'f4t long ( Bof comme arguent ). C'est m\'eame faux.\
\
\
R\'e9cursif\
\
Algo : \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 \CocoaLigature1 InitialiserIndivRecur ( int taille, int prob) -> ListeBit A\
\
Si taille = 0 alors\
	A = creer()\
Sinon\
	Ajouter_Queue_Indiv( InitialiserIndivRecur (taille - 1, prob), random(prob))\
\
Code : \
\pard\tx529\pardeftab529\pardirnatural

\f1\fs22 \cf2 \CocoaLigature0 /* Cree et remplie une liste de bits 'A' de 'taille' valeurs (0 ou 1) selon la probabilite choisie (entre 0 et 100) */\cf0 \
\cf2 /* Algorithme recursif */\cf0 \
\cf3 ListeBit\cf0  InitialiserIndivRecursif(\cf4 int\cf0  taille, \cf4 int\cf0  prob)\{\
    \cf3 ListeBit\cf0  A;\
    \cf4 if\cf0  (taille==\cf4 0\cf0 )					\cf2 /* Cas trivial, taille sert a la fois a donner le nombre de bits de la liste et de compteur */\cf0 \
        \cf4 return\cf0  (A =\cf4 NULL\cf0 );		\cf2 /* Une fois le compteur vide on indique la fin de la liste de bits */\cf0 \
    \cf4 else\cf0 \{										\cf2 /* Appel recursif, d'ou la necessite d'avoir un compteur dans les parametres de la fonction */\cf0 \
        \cf4 return\cf0  (\cf5 Ajouter_Queue_Indiv\cf0 (\cf5 InitialiserIndivRecursif\cf0 (taille-\cf4 1\cf0 , prob), \cf5 random1\cf0 (prob)));	\cf2 /* ajout aleatoire en bout de la liste d'un bit */\cf0 \
    \}\
\}\
\
\
Avantage :\
- Code relativement court\
\
D\'e9savantage :\
- Moins clair \'e0 lire\
\
\
\
\
Il faudrait mesurer le temps d'ex\'e9cution machine, pas encore trouv\'e9 avec xcode.}