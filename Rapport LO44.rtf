{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Courier New;}{\f1\fswiss\fcharset0 ArialMT;}{\f2\fnil\fcharset0 Arial;}{\f3\fswiss\fcharset0 Helvetica;}}
{\*\generator Riched20 6.2.9200}\viewkind4\uc1 
\pard\qc\f0\fs22\lang1036 Rapport du projet LO44\par

\pard\par
\par
\b\fs32 Structures de Donn\'e9es :\b0\fs22\par
\par
\ul\fs28 ListeBit :\ulnone\fs22\par
\par
typedef struct elem\{\par
\tab int valeur;\par
\tab struct elem * suivant;\par
\}Bit;\par
\par
typedef Bit * ListeBit;\par
\par
\ul\fs28 Population :\ulnone\fs22\par
\par
typedef struct elemp\{\par
    ListeBit Indiv;\par
    float qualite;\par
    struct elemp * suivant;\par
\}element;\par
\par
typedef element * Population;\par
\par
\par
\b\fs32 Op\'e9rations \'e9l\'e9mentaires sur les structures de donn\'e9es :\b0\fs22\par
\par
\ul\fs28 ListeBit : \ulnone\fs22\par
\par

\pard\qj\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\b\f1\lang12 Ajouter_Queue_Indiv:\b0  ListeBit A * entier v -> ListeBit\par
\par
R\'e9sultat: \'c0 la fin de la liste de bits A on a rajouter le bit de valeur v\par
Index: newel (bit que l'on va rajouter), p (liste utilis\'e9e pour parcourir A)\par
\par
newel <- CreerI()\par
newel->valeur <- v\par
\par
\ul Si\ulnone  Vide(A) \ul Alors\ulnone\par
\tab A <- newel\par
\ul Sinon\ulnone\par
\tab p <- A\par
\tab\ul Tant que\ulnone  Vide(Reste(p)) \ul Faire\ulnone\par
\tab\tab p <- Reste(p)\par
\tab\ul Fait\ulnone\par
\tab p -> suivant <- newel\par
\ul Fin Si\ulnone\par
\par
\par
\b PrintList:\b0  \par
\par
R\'e9sultat: Imprime les valeurs d'une liste de bits en ligne\par
Index: A (liste de bits \'e0 imprimer), I (liste utilis\'e9e pour parcourir A)\par
\par
\ul Si\ulnone  Vide(A) \ul Alors\ulnone\par
\tab Imprimer("La liste est vide")\par
\ul Sinon\ulnone\par
\tab I <- A\par
\tab\ul Tant que\ulnone  NonVide(I) \ul Faire\ulnone\par
\tab\tab Imprimer (Valeur_Tete(I))\par
\tab\tab I <- Reste(I)\par
\tab\ul Fait\ulnone\par

\pard\sa200\sl276\slmult1\ul Fin SI\par

\pard\ulnone\f0\lang1036\par
\ul\fs28 Population :\ulnone\fs22\par
\par

\pard\qj\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\b\f1\lang12 PrintPop:\b0\par
\par
R\'e9sultat: imprime les valeurs des individus d'une liste d'individus en colonne\par
Index: A (population \'e0 imprimer)\par
\par
\ul Si\ulnone  Vide(A) \ul Alors\ulnone\par
\tab Imprimer("La population est vide")\par
\ul Sinon\ulnone\par
\tab\ul Tant que\ulnone  NonVide(A) \ul Faire\ulnone\par
\tab\tab PrintList(A -> Indiv)\par
\tab\tab A <- Reste(A)\par
\tab\ul Fait\ulnone\par
\ul Fin SI\ulnone\par
\par
\b PrintPopQualite:\b0\par
\par
R\'e9sultat: Imprime les valeurs des individus et leur qualit\'e9 d'une liste d'individus en colonne\par
Index: A (population \'e0 imprimer)\par
\par
\ul Si\ulnone  Vide(A) \ul Alors\ulnone\par
\tab Imprimer("La population est vide")\par
\ul Sinon\ulnone\par
\tab\ul Tant que\ulnone  NonVide(A) \ul Faire\ulnone\par
\tab\tab PrintList(A -> Indiv)\par
\tab\tab Imprimer(A -> qualit\'e9)\par
\tab\tab A <- Reste(A)\par
\tab\ul Fait\ulnone\par
\ul Fin SI\ulnone\par
\par
\par
\b Ajouter_Queue_Pop:\b0\par
\par
R\'e9sultat: Ajoute a une population 'A' un individu supplementaire 'indiv' en fin de liste\par
Index: A (population \'e0 laquelle on va rajouter un individu), indiv (liste de bits que l'on va rajouter en queue de A), LongIndiv (entier donnant la longueur des individus utilis\'e9 pour calculer leur qualit\'e9)\par
\par
newel <- CreerP()\par
newel -> Indiv <- indiv\par
newel -> qualite <- QualiteI(indiv, LongIndiv)\par
\par
\ul Si\ulnone  Vide(A) \ul Alors\ulnone\par
\tab A <- newel\par
\ul Sinon\ulnone\par
\tab p <- A\par
\tab\ul Tant que\ulnone  Vide(Reste(p)) \ul Faire\ulnone\par
\tab\tab p <- Reste(p)\par
\tab\ul Fait\ulnone\par
\tab p -> suivant <- newel\par
\ul Fin Si\ulnone\par
\par
\par
\b DernierPop:\b0  Population P -> Population\par
\par
Algorithme r\'e9cursif\par
R\'e9sultat: Parcourt une liste d'individus et en renvoie le dernier\par
Index: P (population \'e0 parcourir)\par
\par
\ul Si\ulnone  VideP(P) \ul Ou\ulnone  VideP(ResteP(P)) \ul Alors\ulnone\par
\tab Retourner P\par
\ul Sinon\ulnone\par
\tab DernierPop <- DernierPop(ResteP(P))\par
\tab Retourner P\par
\ul Fin Si\ulnone\par
\par
\par
\b Avant_Dernier_Pop:\b0  Population P -> Population\par
\par
\b DernierPop:\b0  Population P -> Population\par
\par
Algorithme r\'e9cursif\par
R\'e9sultat: Parcourt une liste d'individus et en renvoie l'avant-dernier\par
Index: P (population \'e0 parcourir)\par
\par
\ul Si\ulnone  VideP(P) \ul Ou\ulnone  VideP(ResteP(P)) \ul Ou\ulnone  VideP(ResteP(ResteP(P))) \ul Alors\ulnone\par
\tab Retourner P\par
\ul Sinon\ulnone\par
\tab DernierPop <- DernierPop(ResteP(P))\par
\tab Retourner P\par
\ul Fin Si\ulnone\par

\pard\f0\lang1036\par
\par
\b\fs32 Algorithme des fonctions :\par
\par
\ul\b0\fs28 Initialisation et Selection :\ulnone\par
\par

\pard\sa200\sl276\slmult1\b\f2\fs22\lang12 InitPopRecur\b0\par
\par
R\'e9sultat :  Creer de maniere recursive une population d'individu aleatoire suivant une probabilit\'e9 donn\'e9 et suivant une taille de pop donn\'e9e.\par
InitPopRecur (Population p, int TaillePop, int LongIndiv, int prob) -> Population \par
\par
\ul Si\ulnone  TaillePop = 0 \ul alors\ulnone    // TaillePop correspond au compteur pour compter le nombre d'individu \'e0 ajouter \'e0 la population\par
\tab p -> Null   // On marque la fin de la population par l'ajouter de l'element Null\par
\ul Sinon\ulnone\par
InitPopRecur ( p, TaillePop, LongIndiv, prob) = ajouter_queue_pop( InitPopRecur( p, TaillePop -1, LongIndiv, prob), InitialiserIndivRecursif(LongIndiv, prob), Longindiv)\par
//  Definition r\'e9cursive de InitPopRecur\par
\par
\b InitPopIter\b0\par
R\'e9sultat : Creer de maniere i\'e9rative une population d'individu aleatoire suivant une probabilit\'e9 donn\'e9 et suivant une taille de pop donn\'e9e.\par
\par
InitPopIter \lang1036 (Population p, int TaillePop, int LongIndiv, int prob) -> Population p\par
p = creerP()\par
\ul Pour\ulnone  i de 0 \'e0 TaillePop \ul faire\ulnone\par
\tab p = ajouter_queue_pop(p, InitialiserIndivRecursif (LongIndiv, prob), LongIndiv)\par
\ul Fait\ulnone\par
\par
\b PickIP\b0\par
R\'e9sultat : Selection un Individu au hasard dans une population\par
PickIP (Population, p, int TaillePop) -> Indiv\par
n = RandomN(TaillePop)   // On choisi al\'e9atoirement un nombre compris entre 1 et TaillePop\par
\ul Tant que \ulnone i < n \ul faire\ulnone\par
p = ResteP(p)   // On passe au suivant pour trouver l'individu voulu\par
i= i+1\par

\pard\ul fait\par
\par

\pard\sa200\sl276\slmult1\ulnone\b SelectP\par
\b0 R\'e9sultat : Population p avec en fin de liste les tSelect premiers individus recopi\'e9  a la fin de la liste\par
SelectP( Population p, int tSelect, int taillePop, int LongIndiv) -> Population p\par
tSelect = (taillePop*tSelect)/100\par
Population tamp = p\par
i = 1\par
\ul Tant que\ulnone  i < tSelect \ul faire\ulnone\par
\tab tamp = ResteP(tamp)\par
\tab i = i+1\par
\ul\lang12 Fait\par
\ulnone Troncature de la liste :\par
tamp -> suivant = Null\par
Recopie des \'e9l\'e9ments pour completer la liste :\par
\ul Pour\ulnone  i de 1 \'e0 taillePop/tSelect \ul faire\ulnone\par
\tab RecopierP (tamp, p, tSelect, LongIndiv)\par
\ul Fait\par
\ulnone RecopierP (tamp, p, tSelect, LongIndiv)   // On fait appel une derniere fois \'e0 RecopierP au cas ou tSelect ne soit pas un multiple de TaillePop\par
\par
\b coller_liste\par
\b0 R\'e9sultat : Population qui est le resultat du collage de deux populations\par
coller_liste( Population A, Population B) -> Population p\par
Population temp = A\par
\ul Tant que\ulnone  (temp ->suivant != Null) \ul faire\ulnone\par
\tab temp = temp-> suivant\par
\ul Faire\ulnone\par
temp -> suivant = B\par
\ul Fait\ulnone\par
\par
\ul\fs28 Fonctions necessaire au Quicksort : Qualite, Croiser, Recopier, Coller_Liste :\par
\ulnone\b\fs22\lang1036 QualiteP\b0\par
R\'e9sultat : Calcul des qualite des individus d'une population\par
\par
QualiteP(Population p, int LongIndiv) -> Population P   // Recalcule la qualit\'e9 des individus de la population\par
\par
Population P = p\par
\ul Tant que \ulnone (NonVide(p)) \ul faire\ulnone\par
\tab P -> qualite = QualiteI( p -> Indiv, LongIndiv)   // On ajoute la qualite a la population\par
\tab P = ResteP(P)\par
\ul Fait\ulnone\par
\par
\b CroiserP\b0\par
R\'e9sultat : Croisement d'une population\par
\par
CroiserP ( Population p1, int TaillePop, int pCroise, int LongIndiv) -> Population p2\par
Initialisation :\par
Population p2 = CreerP()\par
Population tamp1 = CreerP()\par
Population tamp2 = CreerP()\par
\par
Ajout des 2 individus a p2 :\par
\ul Tant que \ulnone i <= TaillePop \ul faire\ulnone\par
// On choisit 2 individu au hasard dans p1 pour les mettre dans p2\par
\tab p2 = ajouter-queue-pop ( p2, PickIP(p1, TaillePop), LongIndiv)\par
\tab p2 = ajouter-queue-pop ( p2, PickIP(p1, TaillePop), LongIndiv)\par
// Croisement des 2 individus ajout\'e9s :\par
\tab tamp1 = p2\par
\tab tamp2 = p2\par
\tab tamp1 = Avant_Dernier_Pop(p2)\par
\tab tamp2 = Dernier_Pop(p2)\par
\tab CroiserI (tamp1->Indiv, tamp2->Indiv, pCroise)\par
\tab i = i+1\par
\tab i= i+1\par
// Recalcul des qualites\par
\tab QualiteP(p2, LongIndiv)\par
\ul Fait\ulnone\par
\par
\b RecopierP\par
\b0 R\'e9sultat : Population p2 avec nbindiv de p1 recopi\'e9 \'e0 la ifn de p2\par
RecopierP( Population p2, Population p1, int nbindiv, int LongIndiv ) -> Population p2\par
\par
\ul Si\ulnone  nbindiv = 0 \ul alors\ulnone\par
\tab Rien\par
\ul Sinon\par
\ulnone\tab p2 = ajouter_queu_pop ( p2, p1 ->Indiv, LongIndiv)\par
\tab RecopierP ( p2, ResteP(p1), nbindiv-1, LongIndiv)\par
\ul FinSi\par
\f0\fs28 Quicksort :\par

\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ulnone\f3\fs22\lang12 R\'e9sultat : Population avec des individus tri\'e9s par qualit\'e9 croissante\par
\par
Parametrage : quicksort: population A -> population\par
\par
\b Cas trivial:\b0\par
\par
Si vide(A) Alors\par
\tab quicksort=A\par
Fin si\par
\par
\b Cas g\'e9n\'e9ral:\b0\par
\par
Creer(S1)\par
Creer(S2)\par
Creer(P)\par
quicksort <- \'e9l\'e9ment_t\'eate(A))\par
A <- Reste(A)\par
\par
Tant que non_vide(A) Faire\par
\tab Si qualite(\'e9l\'e9ment_t\'eate((quicksort))) < qualite(\'e9l\'e9ment_t\'eate(A))) Faire\par
\tab\tab S1 <- ajouter_queue(element_tete(A))\par
\tab Sinon\par
\tab\tab S2 <- ajouter_queue(element_tete(A))\par
\tab Fin Si\par
\tab A <- Reste(A)\par
Fait\par
\par
Si non_vide (S1) Alors\par
\tab quicksort <- coller_liste(quicksort(S1), quicksort)\par
Fin Si\par
Si non_vide (S2) Alors\par
\tab quicksort <- coller_liste(quicksort, quicksort(S2))\par
Fin Si\par
\par
\b Algorithme:\b0\par
\par
Si vide(A) Alors\par
\tab quicksort=A\par
Sinon\par
\tab Creer(S1)\par
\tab Creer(S2)\par
\tab quicksort <- \'e9l\'e9ment_t\'eate(A))\par
\tab A <- Reste(A)\par
\par
\tab Tant que non_vide(A) Faire\par
\tab\tab Si qualite(\'e9l\'e9ment_t\'eate((quicksort))) < qualite(\'e9l\'e9ment_t\'eate(A))) Faire\par
\tab\tab\tab S1 <- ajouter_queue(element_tete(A))\par
\tab\tab Sinon\par
\tab\tab\tab S2 <- ajouter_queue(element_tete(A))\par
\tab\tab Fin Si\par
\tab\tab A <- Reste(A)\par
\tab Fait\par
\tab Si non_vide (S1) Alors\tab\par
\tab\tab quicksort <- coller_liste(quicksort(S1), quicksort)\par
\tab Fin Si\par
\tab Si non_vide (S2) Alors\par
\tab\tab quicksort <- coller_liste(quicksort, quicksort(S2))\par
\tab Fin Si\par

\pard\sa200\sl276\slmult1 Fin Si\par
\f0\lang1036\par
\par
\par
\b\fs32 Difficult\'e9es rencontr\'e9es lors de la r\'e9alisation du projet :\par
\par
\b0\fs24 + R\'e9alisation du MakeFile :\par
Apr\'e9s moult essaies infructueux cette \'e9tapes fut abandonn\'e9e. La compilation se passe bien lorsqu'elle est r\'e9alis\'e9 \'e0 la main ou sous un ide, mais de nombreuses erreurs li\'e9es aux includes ressortent lorsque l'on utilise le MakeFile.\par
Cela n'a pas d'influence sur le fonctionnement du logiciel mais nous n'avons pas r\'e9ussi a comprendre nos erreur sur le MakeFile.\par
\par
+ Comprehension du Quicksort :\par
L'ennonc\'e9 a \'e9t\'e9 difficile a comprendre pour un des membre du binome. C'est l'esprit de l'algorithme qui n'est pas forcement explicite a la lecture de l'\'e9nonc\'e9. En effet celui ci avait compris que l'algorithme devait couper la liste en un point pr\'e9cis pour donner deux liste bien ordonn\'e9es.\par
Hors cela est impossible et il faut cr\'e9er les deux liste en y placant les \'e9l\'e9ments de la liste de base en fonction de leur qualit\'e9.\par
+ Algorithme du tSelect et CroiserP :\par
A faire par Top\par
\par
Le reste du projet n'a pas pos\'e9 de difficult\'e9es majeurs.\par
\par
\par
\b\fs32 Jeu de test du logiciel :\b0\fs22\par
}
 